#工廠方法模式(Factory Method Pattern)


#模式動機
現在對該系統進行修改，不再設計一個按鈕工廠類來統一負責所有產品的創建，而是將具體按鈕的創建過程交給專門的工廠子類去完成，我們先定義一個抽象的按鈕工廠類，再定義具體的工廠類來生成圓形按鈕、矩形按鈕、菱形按鈕等，它們實現在抽象按鈕工廠類中定義的方法。這種抽象化的結果使這種結構可以在不修改具體工廠類的情況下引進新的產品，如果出現新的按鈕類型，只需要為這種新類型的按鈕創建一個具體的工廠類就可以獲得該新按鈕的實例，這一特點無疑使得工廠方法模式具有超越簡單工廠模式的優越性，更加符合“開閉原則”。

#模式定義
工廠方法模式(Factory Method Pattern)又稱為工廠模式，也叫虛擬構造器(Virtual Constructor)模式或者多態工廠(Polymorphic Factory)模式，它屬於類創建型模式。在工廠方法模式中，工廠父類負責定義創建產品對象的公共接口，而工廠子類則負責生成具體的產品對象，這樣做的目的是將產品類的實例化操作延遲到工廠子類中完成，即通過工廠子類來確定究竟應該實例化哪一個具體產品類。

#模式結構
工廠方法模式包含如下角色：

- Product：抽象產品
- ConcreteProduct：具體產品
- Factory：抽象工廠
- ConcreteFactory：具體工廠

![](../_static/FactoryMethod.jpg)


#時序圖
![](../_static/seq_FactoryMethod.jpg)

#代碼分析
```cpp
///////////////////////////////////////////////////////////
//  ConcreteFactory.cpp
//  Implementation of the Class ConcreteFactory
//  Created on:      02-十月-2014 10:18:58
//  Original author: colin
///////////////////////////////////////////////////////////

#include "ConcreteFactory.h"
#include "ConcreteProduct.h"

ConcreteFactory::ConcreteFactory()
{

}


ConcreteFactory::~ConcreteFactory()
{

}

Product* ConcreteFactory::factoryMethod()
{

    return  new ConcreteProduct();
}

```

```cpp
// main.cpp
#include "Factory.h"
#include "ConcreteFactory.h"
#include "Product.h"
#include <iostream>
using namespace std;

int main(int argc, char* argv[])
{
    Factory* fc = new ConcreteFactory();
    Product* prod = fc->factoryMethod();
    prod->use();

    delete fc;
    delete prod;

    return 0;
}

```

#模式分析
工廠方法模式是簡單工廠模式的進一步抽象和推廣。由於使用了面向對象的多態性，工廠方法模式保持了簡單工廠模式的優點，而且克服了它的缺點。在工廠方法模式中，核心的工廠類不再負責所有產品的創建，而是將具體創建工作交給子類去做。這個核心類僅僅負責給出具體工廠必須實現的接口，而不負責哪一個產品類被實例化這種細節，這使得工廠方法模式可以允許系統在不修改工廠角色的情況下引進新產品。


#實例
日誌記錄器

某系統日誌記錄器要求支持多種日誌記錄方式，如文件記錄、數據庫記錄等，且用戶可以根據要求動態選擇日誌記錄方式，
現使用工廠方法模式設計該系統。

#結構圖：

![](../_static/loger.jpg)

時序圖：

![](../_static/seq_loger.jpg)


#工廠方法模式的優點

- 在工廠方法模式中，工廠方法用來創建客戶所需要的產品，同時還向客戶隱藏了哪種具體產品類將被實例化這一細節，用戶只需要關心所需產品對應的工廠，無須關心創建細節，甚至無須知道具體產品類的類名。

- 基於工廠角色和產品角色的多態性設計是工廠方法模式的關鍵。它能夠使工廠可以自主確定創建何種產品對象，而如何創建這個對象的細節則完全封裝在具體工廠內部。工廠方法模式之所以又被稱為多態工廠模式，是因為所有的具體工廠類都具有同一抽象父類。
- 使用工廠方法模式的另一個優點是在系統中加入新產品時，無須修改抽象工廠和抽象產品提供的接口，無須修改客戶端，也無須修改其他的具體工廠和具體產品，而只要添加一個具體工廠和具體產品就可以了。這樣，系統的可擴展性也就變得非常好，完全符合“開閉原則”。


#工廠方法模式的缺點
- 在添加新產品時，需要編寫新的具體產品類，而且還要提供與之對應的具體工廠類，系統中類的個數將成對增加，在一定程度上增加了系統的複雜度，有更多的類需要編譯和運行，會給系統帶來一些額外的開銷。
- 由於考慮到系統的可擴展性，需要引入抽象層，在客戶端代碼中均使用抽象層進行定義，增加了系統的抽象性和理解難度，且在實現時可能需要用到DOM、反射等技術，增加了系統的實現難度。

#適用環境
在以下情況下可以使用工廠方法模式：

- 一個類不知道它所需要的對象的類：在工廠方法模式中，客戶端不需要知道具體產品類的類名，只需要知道所對應的工廠即可，具體的產品對象由具體工廠類創建；客戶端需要知道創建具體產品的工廠類。
- 一個類通過其子類來指定創建哪個對象：在工廠方法模式中，對於抽象工廠類只需要提供一個創建產品的接口，而由其子類來確定具體要創建的對象，利用面向對象的多態性和里氏代換原則，在程序運行時，子類對象將覆蓋父類對象，從而使得系統更容易擴展。
- 將創建對象的任務委託給多個工廠子類中的某一個，客戶端在使用時可以無須關心是哪一個工廠子類創建產品子類，需要時再動態指定，可將具體工廠類的類名存儲在配置文件或數據庫中。

#模式應用
JDBC中的工廠方法::

```cpp
Connection conn=DriverManager.getConnection("jdbc:microsoft:sqlserver://loc
alhost:1433; DatabaseName=DB;user=sa;password=");
Statement statement=conn.createStatement();
ResultSet rs=statement.executeQuery("select * from UserInfo");
```

#模式擴展
- 使用多個工廠方法：在抽象工廠角色中可以定義多個工廠方法，從而使具體工廠角色實現這些不同的工廠方法，這些方法可以包含不同的業務邏輯，以滿足對不同的產品對象的需求。
- 產品對象的重複使用：工廠對象將已經創建過的產品保存到一個集合（如數組、List等）中，然後根據客戶對產品的請求，對集合進行查詢。如果有滿足要求的產品對象，就直接將該產品返回客戶端；如果集合中沒有這樣的產品對象，那麼就創建一個新的滿足要求的產品對象，然後將這個對象在增加到集合中，再返回給客戶端。
- 多態性的喪失和模式的退化：如果工廠僅僅返回一個具體產品對象，便違背了工廠方法的用意，發生退化，此時就不再是工廠方法模式了。一般來說，工廠對象應當有一個抽象的父類型，如果工廠等級結構中只有一個具體工廠類的話，抽象工廠就可以省略，也將發生了退化。當只有一個具體工廠，在具體工廠中可以創建所有的產品對象，並且工廠方法設計為靜態方法時，工廠方法模式就退化成簡單工廠模式。


#總結
- 工廠方法模式又稱為工廠模式，它屬於類創建型模式。在工廠方法模式中，工廠父類負責定義創建產品對象的公共接口，而工廠子類則負責生成具體的產品對象，這樣做的目的是將產品類的實例化操作延遲到工廠子類中完成，即通過工廠子類來確定究竟應該實例化哪一個具體產品類。
- 工廠方法模式包含四個角色：抽象產品是定義產品的接口，是工廠方法模式所創建對象的超類型，即產品對象的共同父類或接口；具體產品實現了抽象產品接口，某種類型的具體產品由專門的具體工廠創建，它們之間往往一一對應；抽象工廠中聲明瞭工廠方法，用於返回一個產品，它是工廠方法模式的核心，任何在模式中創建對象的工廠類都必須實現該接口；具體工廠是抽象工廠類的子類，實現了抽象工廠中定義的工廠方法，並可由客戶調用，返回一個具體產品類的實例。

- 工廠方法模式是簡單工廠模式的進一步抽象和推廣。由於使用了面向對象的多態性，工廠方法模式保持了簡單工廠模式的優點，而且克服了它的缺點。在工廠方法模式中，核心的工廠類不再負責所有產品的創建，而是將具體創建工作交給子類去做。這個核心類僅僅負責給出具體工廠必須實現的接口，而不負責產品類被實例化這種細節，這使得工廠方法模式可以允許系統在不修改工廠角色的情況下引進新產品。
- 工廠方法模式的主要優點是增加新的產品類時無須修改現有系統，並封裝了產品對象的創建細節，系統具有良好的靈活性和可擴展性；其缺點在於增加新產品的同時需要增加新的工廠，導致系統類的個數成對增加，在一定程度上增加了系統的複雜性。
- 工廠方法模式適用情況包括：一個類不知道它所需要的對象的類；一個類通過其子類來指定創建哪個對象；將創建對象的任務委託給多個工廠子類中的某一個，客戶端在使用時可以無須關心是哪一個工廠子類創建產品子類，需要時再動態指定。

